# Дизайн-документ: NWN2 Systems Platform

## 1. Цель
Создать производительную, масштабируемую и поэтапно развиваемую модульную систему скриптов для персонального сервера NWN2, поддерживающую большое количество игровых механик.

## 2. Архитектурная концепция
**Гибрид:**
1. **Event-driven ядро** для реактивной обработки событий движка.
2. **Локальные area-tick контроллеры** для управления периодическими задачами в пределах областей (area).
3. **SQLite через NWNX** как персистентный слой состояния и метрик.
4. **Глобальный менеджер** только для межобластной координации и агрегированных метрик.

Это снижает центральную contention-точку и распределяет нагрузку по area-boundary.

## 3. Ключевые требования

### 3.1 Функциональные
- Поддержка множества независимых игровых механик в виде модулей.
- Единый lifecycle модулей (init/start/stop/reload).
- Наблюдаемость: сбор runtime-метрик и событий деградации.

### 3.2 Нефункциональные
- Приоритет производительности перед архитектурной «красотой».
- Предсказуемая деградация под нагрузкой (graceful degradation).
- Минимизация глобальных синхронных операций в игровом тике.

## 4. Runtime-модель

### 4.1 Event-driven ядро
Ядро обрабатывает входящие игровые события и маршрутизирует их в модульные handlers с фиксированным контрактом.

### 4.2 Area-tick контроллеры
Для каждой области создаётся локальный контроллер:
- **Бакетирование:** распределение NPC/задач по N корзинам;
- **Jitter:** псевдослучайный сдвиг периода обработки во избежание «шипов»;
- **Step-based handlers:** выполнение тяжёлой логики порциями в несколько шагов/тиков.

Детали runtime-контракта см. `docs/npc_runtime_orchestration.md`.

### 4.3 Глобальный менеджер
Используется только для:
- кросс-area задач (например, глобальные сезонные эффекты);
- агрегации метрик и health-сигналов.

## 5. Персистентность (NWNX + SQLite)
- SQLite хранит долговременное состояние модулей и статистику.
- Пишем пакетно/асинхронно относительно логики тика там, где это допустимо игровыми ограничениями.
- Доступ к БД оборачивается в thin repository слой, чтобы не «протекал» SQL в игровую логику.

## 6. Процесс принятия решений на основе исследований
Перед любым значимым архитектурным решением обязателен performance-review:
1. Гипотеза и минимум два альтернативных подхода.
2. План измерения (сценарий, длительность, метрики).
3. Замеры (минимум 3 прогона).
4. Решение по итогам данных (а не интуиции).
5. Фиксация результата в `docs/` + ссылка на benchmark-данные.

## 7. Первая итерация: модуль поведения NPC

### 7.1 Scope
Модуль должен регулировать поведение NPC и включать:
- idle-поведение и патрулирование;
- реакцию на триггеры/персепшен;
- управление агрессией и возвратом к базовым состояниям;
- ограничение частоты тяжёлых вычислений через area-tick контроллеры.

### 7.2 Производительные паттерны
- Отказ от «полного пересчёта всех NPC каждый тик».
- Выделение «горячих» и «холодных» веток логики.
- Дедупликация событий и антидребезг состояний.
- Лимит на объём обработки за тик (tick budget cap).

### 7.3 Метрики успеха
- Стабильный tick time под целевой NPC-нагрузкой.
- Отсутствие периодических latency-spike при пиковых событиях.
- Воспроизводимость поведения NPC при reload модуля.

## 8. План этапов
1. Каркас ядра событий и контракт модулей.
2. Реализация area-tick контроллера с бакетами/jitter.
3. Интеграция NWNX SQLite и базовая схема хранения.
4. MVP модуля поведения NPC.
5. Бенчмарки и оптимизация горячих путей.

## 9. Критерии готовности первой фазы
- [x] Зафиксирована целевая архитектурная концепция.
- [x] Определён performance-first процесс принятия решений.
- [x] Описан scope первой целевой механики (NPC behavior).
- [ ] Подготовлены baseline benchmark-сценарии.
- [ ] Реализован и подключен MVP модуля NPC behavior.
